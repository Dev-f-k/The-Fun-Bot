from __future__ import unicode_literals
from pyrogram import Client, filters
from info import START_IMG, LOOK_IMG, COMMAND_HAND_LER, MOVIE_PIC, ADMINS, API_HASH, API_ID, BOT_TOKEN, MV_PIC, FSub_Channel, SESSION
from script import START_TXT, LOOK_TXT, HELP_TXT, ABOUT_TXT, SOURCE_TXT, MOVIE_ENG_TXT, MOVIE_MAL_TXT, OWNER_INFO, MV_TXT, KICKED, FSUB, COMMAND_USER, WAIT_MSG, REPLY_ERROR
from pyrogram.types import InlineKeyboardMarkup, InlineKeyboardButton, CallbackQuery, Message, InlineQuery, InlineQueryResultArticle, InputTextMessageContent
from pyrogram.errors import UserNotParticipant, FloodWait, MessageNotModified
from plugins.fun_strings import FUN_STRINGS
from urllib.parse import quote
from youtube_search import YoutubeSearch
from youtubesearchpython import SearchVideos
from aiohttp import ClientSession
from plugins.function import make_carbon
from yt_dlp import YoutubeDL
import youtube_dl
import math
import time
import aiohttp
import yt_dlp
import wget
import aiofiles
import requests
import random
import os
import asyncio
import users

SUPPORT_CHAT = "filmy_harbour_support"
aiohttpsession = ClientSession()

C = "**Join @filmy_harbour and @FH_MV**"
F = InlineKeyboardMarkup(
[[
     InlineKeyboardButton("¬© F…™ ü·¥ç è H·¥Ä Ä ô·¥è·¥ú Ä", url="https://t.me/FH_MV")
]]
)

tgbot=Client(
    session_name=SESSION,
    bot_token=BOT_TOKEN,
    api_id=API_ID,
    api_hash=API_HASH
)

@tgbot.on_message(filters.command("start"))
async def start_message(bot, message):
    usr = open("users.txt", "w")
    if message.from_user.id not in users.txt:
        usr.write("New User "+str(message.from_user.mention)+"with ID: "+str(message.from_user.id))
        usr.close()
    else:
        usr.close()
    if FSub_Channel:
        try:
            user = await bot.get_chat_member(FSub_Channel, message.from_user.id)
            if user.status == "kicked out":
                await message.reply_text(KICKED.format(message.from_user.mention))
                return
        except UserNotParticipant:
            await message.reply_text(
                text=(FSUB.format(message.from_user.mention)),
                reply_markup=InlineKeyboardMarkup(
                  [[
                    InlineKeyboardButton("Join Our Updates Channel üì¢", url=f"t.me/{FSub_Channel}")
                 ],[
                    InlineKeyboardButton("Try Again üîÑ", url="t.me/the_fun_mallu_bot?start")
                  ]]
                )
            )

            return
    n = await message.reply_text("<b>Processing</b>")
    await asyncio.sleep(0.5)
    await n.edit_text("<b>Processing.</b>")
    await asyncio.sleep(0.5)
    await n.edit_text("<b>Processing..</b>")
    await asyncio.sleep(0.5)
    await n.edit_text("<b>Processing...</b>")
    await asyncio.sleep(1)
    await n.delete()

    await message.reply_photo(
            photo=random.choice(START_IMG),
            caption=(START_TXT.format(message.from_user.mention)),
            reply_markup=InlineKeyboardMarkup(
                      [[
                        InlineKeyboardButton('‚ûï ·¥Ä·¥Ö·¥Ö ·¥ç·¥á ·¥õ·¥è  è·¥è·¥ú Ä …¢ Ä·¥è·¥ú·¥ò ‚ûï', url=f'https://t.me/auto_m4_mallumovies_bot?startgroup=true')
                     ],[
                        InlineKeyboardButton('ü§¥ ô·¥è·¥õ ·¥è·¥°…¥·¥á Äü§¥', callback_data="owner_info"),
                        InlineKeyboardButton('üçø·¥ç·¥è·¥†…™·¥á …¢ Ä·¥è·¥ú·¥òüçø', callback_data="movie_grp")
                     ],[
                        InlineKeyboardButton('‚ÑπÔ∏è  ú·¥á ü·¥ò', callback_data='help'),
                        InlineKeyboardButton('üòä ·¥Ä ô·¥è·¥ú·¥õ', callback_data='about')
                     ],[
                        InlineKeyboardButton('üí• ·¥ä·¥è…™…¥ ·¥è·¥ú Ä ·¥ç·¥Ä…™…¥ ·¥Ñ ú·¥Ä…¥…¥·¥á ü üí•', url='https://t.me/+LJRsBp82HiJhNDhl')
                      ]]
            
            ),
            parse_mode='html'

)



@tgbot.on_message(filters.regex("movie") | filters.regex("Movie") & filters.group)
async def filter_handler(bot, message):
    if message.from_user.id not in ADMINS:
        await message.reply_photo(
            photo=(MOVIE_PIC),
            caption=(MOVIE_ENG_TXT.format(message.from_user.mention)),
            reply_markup=InlineKeyboardMarkup(
                      [[
                        InlineKeyboardButton('üáÆüá≥ Translate to Malayalam üáÆüá≥', callback_data='movie_mal_txt')
                      ]]
            
            ),
            parse_mode="html"
)
    else:
        pro = await message.reply_text(f"<b>Hey {message.from_user.mention}, You are approved as Admin ‚úÖ</b>")
        await asyncio.sleep(5)
        await pro.delete()



@tgbot.on_callback_query()
async def cb_checker(bot, query: CallbackQuery):
        if query.data == "close_data":
            await query.message.delete()

        elif query.data == "start":
            buttons = [[
                        InlineKeyboardButton('‚ûï ·¥Ä·¥Ö·¥Ö ·¥ç·¥á ·¥õ·¥è  è·¥è·¥ú Ä …¢ Ä·¥è·¥ú·¥ò ‚ûï', url=f'https://t.me/auto_m4_mallumovies_bot?startgroup=true')
                     ],[
                        InlineKeyboardButton('ü§¥ ô·¥è·¥õ ·¥è·¥°…¥·¥á Äü§¥', callback_data="owner_info"),
                        InlineKeyboardButton('üçø·¥ç·¥è·¥†…™·¥á …¢ Ä·¥è·¥ú·¥òüçø', callback_data="movie_grp")
                     ],[
                        InlineKeyboardButton('‚ÑπÔ∏è  ú·¥á ü·¥ò', callback_data='help'),
                        InlineKeyboardButton('üòä ·¥Ä ô·¥è·¥ú·¥õ', callback_data='about')
                     ],[
                        InlineKeyboardButton('üí• ·¥ä·¥è…™…¥ ·¥è·¥ú Ä ·¥ç·¥Ä…™…¥ ·¥Ñ ú·¥Ä…¥…¥·¥á ü üí•', url='https://t.me/+LJRsBp82HiJhNDhl')
                      ]]
            
            reply_markup = InlineKeyboardMarkup(buttons)
            await query.message.edit_text(
                text=(START_TXT.format(query.from_user.mention)),
                reply_markup=reply_markup,
                parse_mode='html'
            )

        elif query.data == "help":
            buttons = [[
                          InlineKeyboardButton('üè†  ú·¥è·¥ç·¥á', callback_data='start'),
                          InlineKeyboardButton('üòä ·¥Ä ô·¥è·¥ú·¥õ', callback_data='about')
                      ],[
                          InlineKeyboardButton('üîê ·¥Ñ ü·¥ès·¥á', callback_data='close_data'),
                          InlineKeyboardButton('‚ù§Ô∏è s·¥è·¥ú Ä·¥Ñ·¥á', callback_data='sourcehelp')
                      ]]
            
            reply_markup = InlineKeyboardMarkup(buttons)
            await query.message.edit_text(
                text=(HELP_TXT.format(query.from_user.mention)),
                reply_markup=reply_markup,
                parse_mode='html'
            )
            await query.answer('W·¥á ü·¥Ñ·¥è·¥ç·¥á T·¥è M è H·¥á ü·¥ò M·¥è·¥Ö·¥ú ü·¥á')

        elif query.data == "about":
            buttons = [[
                          InlineKeyboardButton('üè†  ú·¥è·¥ç·¥á', callback_data='start'),
                          InlineKeyboardButton('‚ÑπÔ∏è  ú·¥á ü·¥ò', callback_data='help')
                      ],[
                          InlineKeyboardButton('üîê ·¥Ñ ü·¥ès·¥á', callback_data='close_data'),
                          InlineKeyboardButton('‚ù§Ô∏è s·¥è·¥ú Ä·¥Ñ·¥á', callback_data='source')
                      ]]
            
            reply_markup = InlineKeyboardMarkup(buttons)
            await query.message.edit_text(
                text=(ABOUT_TXT.format(query.from_user.mention)),
                reply_markup=reply_markup,
                parse_mode='html'
            )
            await query.answer("W·¥á ü·¥Ñ·¥è·¥ç·¥á T·¥è M è A ô·¥è·¥ú·¥õ M·¥è·¥Ö·¥ú ü·¥á")

        elif query.data == "source":
            buttons = [[
                        InlineKeyboardButton('üîô  ô·¥Ä·¥Ñ·¥ã', callback_data='about'),
                        InlineKeyboardButton('üîê ·¥Ñ ü·¥ès·¥á', callback_data='close_data')
                      ]]
            
            reply_markup = InlineKeyboardMarkup(buttons)
            await query.message.edit_text(
                text=(SOURCE_TXT),
                reply_markup=reply_markup,
                parse_mode='html'
            )

        elif query.data == "sourcehelp":
            buttons = [[
                        InlineKeyboardButton('üîô  ô·¥Ä·¥Ñ·¥ã', callback_data='help'),
                        InlineKeyboardButton('üîê ·¥Ñ ü·¥ès·¥á', callback_data='close_data')
                      ]]
            
            reply_markup = InlineKeyboardMarkup(buttons)
            await query.message.edit_text(
                text=(SOURCE_TXT),
                reply_markup=reply_markup,
                parse_mode='html'
            )

        elif query.data == "owner_info":
            btn = [[
                    InlineKeyboardButton("üîô  ô·¥Ä·¥Ñ·¥ã", callback_data="start"),
                    InlineKeyboardButton("·¥Ñ·¥è…¥·¥õ·¥Ä·¥Ñ·¥õ", url="t.me/creatorbeatz")
                  ]]
            reply_markup = InlineKeyboardMarkup(btn)
            await query.message.edit_text(
                text=(OWNER_INFO),
                reply_markup=reply_markup,
                parse_mode='html'
            )

        elif query.data == "movie_mal_txt":
            btn = [[
                    InlineKeyboardButton("üá∫üá≤ Translate to English üá∫üá≤", callback_data="movie_eng_txt")
                  ]]
            reply_markup = InlineKeyboardMarkup(btn)
            try:
                if query.from_user.id == query.message.reply_to_message.from_user.id:
                    await query.message.edit_text(
                        text=(MOVIE_MAL_TXT.format(query.from_user.mention)),
                        reply_markup=reply_markup,
                        parse_mode='html'
                    )
                
                else:
                    await query.answer("This is not for you !", show_alert=True)
            except AttributeError:
                    await query.answer("Button Expired !", show_alert=True)

        elif query.data == "movie_eng_txt":
            btn = [[
                    InlineKeyboardButton("üáÆüá≥ Translate to Malayalam üáÆüá≥", callback_data="movie_mal_txt")
                  ]]
            reply_markup = InlineKeyboardMarkup(btn)
            try:
                if query.from_user.id == query.message.reply_to_message.from_user.id:
                    await query.message.edit_text(
                        text=(MOVIE_ENG_TXT.format(query.from_user.mention)),
                        reply_markup=reply_markup,
                        parse_mode='html'
                    )
                
                else:
                    await query.answer("This is not for you !", show_alert=True)
            except AttributeError:
                    await query.answer("Button Expired !", show_alert=True)

        elif query.data == "movie_grp":
            btn = [[
                    InlineKeyboardButton("·¥Ñ ü…™·¥Ñ·¥ã ·¥ç·¥á ·¥õ·¥è ·¥ä·¥è…™…¥ …¢ Ä·¥è·¥ú·¥ò", url="https://t.me/+5olNhPeyW31jYjBl"),
                    InlineKeyboardButton(" ô·¥Ä·¥Ñ·¥ã-·¥ú·¥ò ·¥Ñ ú·¥Ä…¥…¥·¥á ü", url="https://t.me/+asOwq8hpxSgwOTY9")
                 ],[
                    InlineKeyboardButton("…¥·¥á·¥°  Ä·¥á ü·¥á·¥Äs·¥ás", url="https://t.me/+1Zr7U1TCCMw2YmJl"),
                    InlineKeyboardButton("·¥Ñ ü·¥ès·¥á", callback_data="close_data")
                  ]]
            reply_markup = InlineKeyboardMarkup(btn)
            await query.message.reply_photo(
                photo=(MV_PIC),
                caption=(MV_TXT),
                reply_markup=reply_markup,
                parse_mode='html'
            )           

@tgbot.on_message(filters.command("howilook"))
async def howilook_message(bot, message):
    await message.reply_photo(
            photo=random.choice(LOOK_IMG),
            caption=(LOOK_TXT.format(message.from_user.first_name)),
            parse_mode='html'
)

# EMOJI CONSTANTS
DICE_E_MOJI = "üé≤"
# EMOJI CONSTANTS


@tgbot.on_message(
    filters.command(["roll", "dice"], COMMAND_HAND_LER)
)
async def roll_dice(client, message):
    """ @RollaDie """
    rep_mesg_id = message.message_id
    if message.reply_to_message:
        rep_mesg_id = message.reply_to_message.message_id
    await client.send_dice(
        chat_id=message.chat.id,
        emoji=DICE_E_MOJI,
        disable_notification=True,
        reply_to_message_id=rep_mesg_id
    )

# EMOJI CONSTANTS
DART_E_MOJI = "üéØ"
# EMOJI CONSTANTS


@tgbot.on_message(
    filters.command(["throw", "dart"], COMMAND_HAND_LER)
)
async def throw_dart(client, message):
    """ /throw an @AnimatedDart """
    rep_mesg_id = message.message_id
    if message.reply_to_message:
        rep_mesg_id = message.reply_to_message.message_id
    await client.send_dice(
        chat_id=message.chat.id,
        emoji=DART_E_MOJI,
        disable_notification=True,
        reply_to_message_id=rep_mesg_id
    )

# EMOJI CONSTANTS
GOAL_E_MOJI = "‚öΩ"
# EMOJI CONSTANTS


@tgbot.on_message(
    filters.command(["goal", "shoot"], COMMAND_HAND_LER)
)
async def roll_dice(client, message):
    """ @Goal """
    rep_mesg_id = message.message_id
    if message.reply_to_message:
        rep_mesg_id = message.reply_to_message.message_id
    await client.send_dice(
        chat_id=message.chat.id,
        emoji=GOAL_E_MOJI,
        disable_notification=True,
        reply_to_message_id=rep_mesg_id
    )

# EMOJI CONSTANTS
PIN_BALL = "üé≥"
# EMOJI CONSTANTS

@tgbot.on_message(
    filters.command(["pinball", "tenpin"])
)
async def pinball_tenpin(client, message):
    """ /pinball an @animatedpinball """
    rep_mesg_id = message.message_id
    if message.reply_to_message:
        rep_mesg_id = message.reply_to_message.message_id
    await client.send_dice(
        chat_id=message.chat.id,
        emoji=PIN_BALL,
        disable_notification=True,
        reply_to_message_id=rep_mesg_id
    )

# EMOJI CONSTANTS
TRY_YOUR_LUCK = "üé∞"
# EMOJI CONSTANTS

@tgbot.on_message(
    filters.command(["luck", "cownd"])
)
async def luck_cownd(client, message):
    """ /luck an @animatedluck """
    rep_mesg_id = message.message_id
    if message.reply_to_message:
        rep_mesg_id = message.reply_to_message.message_id
    await client.send_dice(
        chat_id=message.chat.id,
        emoji=TRY_YOUR_LUCK,
        disable_notification=True,
        reply_to_message_id=rep_mesg_id
    )


@tgbot.on_message(
    filters.command("fun", COMMAND_HAND_LER)
)
async def runs(_, message):
    await message.reply_chat_action("Typing")
    await asyncio.sleep(2)
    """ /fun strings """
    effective_string = random.choice(FUN_STRINGS)
    if message.reply_to_message:
        await message.reply_to_message.reply_text(effective_string)
    else:
        await message.reply_text(effective_string)

def share_link(text: str) -> str:
    return "**Here is Your Sharing Text üëá**\n\nhttps://t.me/share/url?url=" + quote(text)

@tgbot.on_message(filters.command(["share", "sharetext", "st", "stxt", "shtxt", "shtext"]))
async def share_text(client, message):
    reply = message.reply_to_message
    reply_id = message.reply_to_message.message_id if message.reply_to_message else message.message_id
    input_split = message.text.split(None, 1)
    if len(input_split) == 2:
        input_text = input_split[1]
    elif reply and (reply.text or reply.caption):
        input_text = reply.text or reply.caption
    else:
        await message.reply_text(
            text=f"**Notice:**\n\n1. Reply Any Messages.\n2. No Media Support\n\n**Any Question Join Support Chat**",
            reply_markup=InlineKeyboardMarkup(
                [
                    [
                        InlineKeyboardButton(
                            "Support Chat", url=f"https://t.me/{SUPPORT_CHAT}")
                    ]                
                ]
            ),
            reply_to_message_id=reply_id
        )
        return
    await message.reply_text(share_link(input_text), reply_to_message_id=reply_id)

@tgbot.on_message((filters.command(["report"]) | filters.regex("@admins") | filters.regex("@admin")) & filters.group)
async def report_user(bot, message):
    if message.reply_to_message:
        chat_id = message.chat.id
        reporter = str(message.from_user.id)
        mention = message.from_user.mention
        admins = await bot.get_chat_members(chat_id=chat_id, filter="administrators")
        success = True
        report = f"ùñ±ùñæùóâùóàùóãùóçùñæùóã : {mention} ({reporter})" + "\n"
        report += f"ùñ¨ùñæùóåùóåùñ∫ùóÄùñæ : {message.reply_to_message.link}"
        for admin in admins:
            try:
                reported_post = await message.reply_to_message.forward(admin.user.id)
                await reported_post.reply_text(
                    text=report,
                    chat_id=admin.user.id,
                    disable_web_page_preview=True
                )
                success = True
            except:
                pass
        if success:
            await message.reply_text(f"Hey {message.from_user.mention}, Your Report Has Been Sent Tùóà ùñ†ùñΩùóÜùóÇùóáùóå!")    
            
def time_to_seconds(time):
    stringt = str(time)
    return sum(int(x) * 60 ** i for i, x in enumerate(reversed(stringt.split(':'))))


@tgbot.on_message(filters.command('song') & ~filters.private & ~filters.channel)
def song(client, message):

    user_id = message.from_user.id 
    user_name = message.from_user.first_name 
    rpk = "["+user_name+"](tg://user?id="+str(user_id)+")"

    query = ''
    for i in message.command[1:]:
        query += ' ' + str(i)
    print(query)
    m = message.reply("**—ï—îŒ±rch√≠ng —áœÉur —ïœÉng...!**")
    ydl_opts = {"format": "bestaudio[ext=m4a]"}
    try:
        results = YoutubeSearch(query, max_results=1).to_dict()
        link = f"https://youtube.com{results[0]['url_suffix']}"
        #print(results)
        title = results[0]["title"][:40]       
        thumbnail = results[0]["thumbnails"][0]
        thumb_name = f'thumb{title}.jpg'
        thumb = requests.get(thumbnail, allow_redirects=True)
        open(thumb_name, 'wb').write(thumb.content)


        performer = f"[·ó©·íç·ó©·ô≠]" 
        duration = results[0]["duration"]
        url_suffix = results[0]["url_suffix"]
        views = results[0]["views"]

    except Exception as e:
        m.edit(
            "**ùôµùôæùöÑùôΩùô≥ ùôΩùôæùöÉùô∑ùô∏ùôΩùô∂ ùôøùôªùô¥ùô∞ùöÇùô¥ ùô≤ùôæùöÅùöÅùô¥ùô≤ùöÉ ùöÉùô∑ùô¥ ùöÇùôøùô¥ùôªùôªùô∏ùôΩùô∂ ùôæùöÅ ùöÇùô¥ùô∞ùöÅùô≤ùô∑ ùô∞ùôΩùöà ùôæùöÉùô∑ùô¥ùöÅ ùöÇùôæùôΩùô∂**"
        )
        print(str(e))
        return
    m.edit("**dœÉwnlœÉŒ±d√≠ng —áœÉur —ïœÉng...!**")
    try:
        with yt_dlp.YoutubeDL(ydl_opts) as ydl:
            info_dict = ydl.extract_info(link, download=False)
            audio_file = ydl.prepare_filename(info_dict)
            ydl.process_info(info_dict)
        rep = '**ùöÇùöÑùô±ùöÇùô≤ùöÅùô∏ùô±ùô¥ ‚Ä∫‚Ä∫ [ùôæùôøùöÑùöÇ-ùöÉùô¥ùô≤ùô∑ùöâ](https://youtube.com/channel/UCf_dVNrilcT0V2R--HbYpMA)**\n**ùôøùôæùöÜùô¥ùöÅùô¥ùô≥ ùô±ùöà ‚Ä∫‚Ä∫ [mu—ï√≠c –≤œÉ—á](https://t.me/OPMusicBoy_Bot)**'
        secmul, dur, dur_arr = 1, 0, duration.split(':')
        for i in range(len(dur_arr)-1, -1, -1):
            dur += (int(dur_arr[i]) * secmul)
            secmul *= 60
        message.reply_audio(audio_file, caption=rep, parse_mode='md',quote=False, title=title, duration=dur, performer=performer, thumb=thumb_name)
        m.delete()
    except Exception as e:
        m.edit("**üö´ ùô¥ùöÅùöÅùôæùöÅ üö´**")
        print(e)

    try:
        os.remove(audio_file)
        os.remove(thumb_name)
    except Exception as e:
        print(e)

def get_text(message: Message) -> [None,str]:
    text_to_return = message.text
    if message.text is None:
        return None
    if " " not in text_to_return:
        return None
    try:
        return message.text.split(None, 1)[1]
    except IndexError:
        return None


@tgbot.on_message(filters.command(["video", "mp4"]))
async def vsong(client, message: Message):
    urlissed = get_text(message)

    pablo = await client.send_message(
        message.chat.id, f"**ùôµùô∏ùôΩùô≥ùô∏ùôΩùô∂ ùöàùôæùöÑùöÅ ùöÖùô∏ùô≥ùô¥ùôæ** `{urlissed}`"
    )
    if not urlissed:
        await pablo.edit("Invalid Command Syntax Please Check help Menu To Know More!")
        return

    search = SearchVideos(f"{urlissed}", offset=1, mode="dict", max_results=1)
    mi = search.result()
    mio = mi["search_result"]
    mo = mio[0]["link"]
    thum = mio[0]["title"]
    fridayz = mio[0]["id"]
    mio[0]["channel"]
    kekme = f"https://img.youtube.com/vi/{fridayz}/hqdefault.jpg"
    await asyncio.sleep(0.6)
    url = mo
    sedlyf = wget.download(kekme)
    opts = {
        "format": "best",
        "addmetadata": True,
        "key": "FFmpegMetadata",
        "prefer_ffmpeg": True,
        "geo_bypass": True,
        "nocheckcertificate": True,
        "postprocessors": [{"key": "FFmpegVideoConvertor", "preferedformat": "mp4"}],
        "outtmpl": "%(id)s.mp4",
        "logtostderr": False,
        "quiet": True,
    }
    try:
        with YoutubeDL(opts) as ytdl:
            ytdl_data = ytdl.extract_info(url, download=True)
    except Exception as e:
        await event.edit(event, f"**ùô≥ùöòùö†ùöóùöïùöòùöäùöç ùôµùöäùöíùöïùöéùöç ùôøùöïùöéùöäùöúùöé ùöÉùöõùö¢ ùô∞ùöêùöäùöíùöó..‚ô•Ô∏è** \n**Error :** `{str(e)}`")
        return
    c_time = time.time()
    file_stark = f"{ytdl_data['id']}.mp4"
    capy = f"""
**ùöÉùô∏ùöÉùôªùô¥ :** [{thum}]({mo})
**ùöÅùô¥ùöÄùöÑùô¥ùöÇùöÉùô¥ùô≥ ùô±ùöà :** {message.from_user.mention}
"""
    await client.send_video(
        message.chat.id,
        video=open(file_stark, "rb"),
        duration=int(ytdl_data["duration"]),
        file_name=str(ytdl_data["title"]),
        thumb=sedlyf,
        caption=capy,
        supports_streaming=True,        
        reply_to_message_id=message.message_id 
    )
    await pablo.delete()
    for files in (sedlyf, file_stark):
        if files and os.path.exists(files):
            os.remove(files)

@tgbot.on_inline_query()
async def inline(bot, query: InlineQuery):
    await query.answer(
        results = [
            InlineQueryResultArticle(
                title = "Movies",
                description = "For new and old movies and series in all languages, CLICK ME !",
                thumb_url = "https://telegra.ph/file/7c924bffb69a01d834ba4.jpg",
                input_message_content = InputTextMessageContent(
                    message_text = (MV_TXT)
                ),
                reply_markup = InlineKeyboardMarkup(
                [[
                  InlineKeyboardButton("·¥ä·¥è…™…¥ ·¥ç·¥è·¥†…™·¥á …¢ Ä·¥è·¥ú·¥ò", url="https://t.me/+5olNhPeyW31jYjBl"),
                  InlineKeyboardButton(" ô·¥Ä·¥Ñ·¥ã-·¥ú·¥ò ·¥Ñ ú·¥Ä…¥…¥·¥á ü", url="https://t.me/+asOwq8hpxSgwOTY9")
               ],[
                  InlineKeyboardButton("…¥·¥á·¥°  Ä·¥á ü·¥á·¥Äs·¥ás", url="https://t.me/+1Zr7U1TCCMw2YmJl")
                ]]
                )
            )
        ],
        cache_time = 0
    )

@tgbot.on_message(filters.command("trash") & filters.group)
async def trash_handler(bot, message):
    if message.from_user.id not in ADMINS:
        await message.reply_text("<b>Hey bro, This is an Admin Command !</b>")
    else:
        try:
            await message.reply_to_message.delete()
            await message.delete()
        except AttributeError:
            await message.reply_text("<b>Hey, Use this command as a reply to any message...</b>")

@tgbot.on_message(filters.command("carbon"))
async def carbon_func(_, message):
    if not message.reply_to_message:
        return await message.reply_text(
            " Ä·¥á·¥ò ü è ·¥õ·¥è ·¥Ä ·¥õ·¥áx·¥õ ·¥ç·¥áss·¥Ä…¢·¥á ·¥õ·¥è ·¥ç·¥Ä·¥ã·¥á ·¥Ñ·¥Ä Ä ô·¥è…¥."
        )
    if not message.reply_to_message.text:
        return await message.reply_text(
            " Ä·¥á·¥ò ü è ·¥õ·¥è ·¥Ä ·¥õ·¥áx·¥õ ·¥ç·¥áss·¥Ä…¢·¥á ·¥õ·¥è ·¥ç·¥Ä·¥ã·¥á ·¥Ñ·¥Ä Ä ô·¥è…¥."
        )
    user_id = message.from_user.id
    m = await message.reply_text("·¥ò Ä·¥è·¥Ñ·¥áss…™…¥…¢...")
    carbon = await make_carbon(message.reply_to_message.text)
    await m.edit("·¥ú·¥ò ü·¥è·¥Ä·¥Ö…™…¥…¢..")
    await message.reply_photo(
        photo=carbon,
        caption=C,
        reply_markup=F)
    await m.delete()
    carbon.close()

tgbot.run()
